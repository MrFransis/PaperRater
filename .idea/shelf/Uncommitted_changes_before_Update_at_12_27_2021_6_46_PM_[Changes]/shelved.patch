Index: PaperRaterApp/src/main/java/it/unipi/dii/lsmd/paperraterapp/persistence/MongoDBManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.unipi.dii.lsmd.paperraterapp.persistence;\r\n\r\nimport com.google.gson.Gson;\r\nimport com.google.gson.GsonBuilder;\r\nimport com.google.gson.JsonSyntaxException;\r\nimport com.google.gson.reflect.TypeToken;\r\nimport com.mongodb.client.MongoClient;\r\nimport com.mongodb.client.MongoCollection;\r\nimport com.mongodb.client.MongoCursor;\r\nimport com.mongodb.client.MongoDatabase;\r\nimport com.mongodb.client.model.Aggregates;\r\nimport com.mongodb.client.model.Filters;\r\nimport com.mongodb.client.model.Indexes;\r\nimport com.mongodb.client.model.Updates;\r\nimport com.mongodb.client.result.UpdateResult;\r\nimport it.unipi.dii.lsmd.paperraterapp.model.Comment;\r\nimport it.unipi.dii.lsmd.paperraterapp.model.Paper;\r\nimport it.unipi.dii.lsmd.paperraterapp.model.ReadingList;\r\nimport it.unipi.dii.lsmd.paperraterapp.model.User;\r\nimport javafx.util.Pair;\r\nimport org.bson.Document;\r\nimport org.bson.conversions.Bson;\r\n\r\nimport java.lang.reflect.Type;\r\nimport java.text.SimpleDateFormat;\r\nimport java.time.LocalDateTime;\r\nimport java.time.format.DateTimeFormatter;\r\nimport java.util.*;\r\nimport java.util.function.Consumer;\r\nimport java.util.regex.Pattern;\r\n\r\nimport static com.mongodb.client.model.Accumulators.sum;\r\nimport static com.mongodb.client.model.Aggregates.*;\r\nimport static com.mongodb.client.model.Filters.*;\r\nimport static com.mongodb.client.model.Indexes.ascending;\r\nimport static com.mongodb.client.model.Projections.*;\r\nimport static com.mongodb.client.model.Sorts.descending;\r\n\r\n\r\npublic class MongoDBManager {\r\n    public MongoDatabase db;\r\n    private MongoCollection usersCollection;\r\n    private MongoCollection papersCollection;\r\n\r\n\r\n    /**\r\n     *\r\n     * @param client MongoDBClient\r\n     */\r\n    public MongoDBManager(MongoClient client) {\r\n        this.db = client.getDatabase(\"PaperRater\");\r\n        usersCollection = db.getCollection(\"Users\");\r\n        papersCollection = db.getCollection(\"Papers\");\r\n    }\r\n\r\n    // da correggere\r\n    public int getNumUsers (String keyword) {\r\n        List<User> results = new ArrayList<>();\r\n        Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n        Consumer<Document> convertInUser = doc -> {\r\n            User user = gson.fromJson(gson.toJson(doc), User.class);\r\n            results.add(user);\r\n        };\r\n        Pattern pattern= Pattern.compile(\"^.*\" + keyword + \".*$\", Pattern.CASE_INSENSITIVE);\r\n        Bson filter = Aggregates.match(Filters.regex(\"username\", pattern));\r\n        usersCollection.aggregate(Arrays.asList(filter)).forEach(convertInUser);\r\n        return results.size();\r\n    }\r\n\r\n    /**\r\n     * Return users the contains the keyword, by\r\n     * @param keyword keyword to search users\r\n     * @return list of users\r\n     */\r\n    public List<User> getUsersByKeyword (String keyword, int next) {\r\n        List<User> results = new ArrayList<>();\r\n        Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();\r\n        Consumer<Document> convertInUser = doc -> {\r\n            User user = gson.fromJson(gson.toJson(doc), User.class);\r\n            results.add(user);\r\n        };\r\n        Pattern pattern= Pattern.compile(\"^.*\" + keyword + \".*$\", Pattern.CASE_INSENSITIVE);\r\n        Bson filter = Aggregates.match(Filters.regex(\"username\", pattern));\r\n        Bson limit = limit(8);\r\n        Bson skip = skip(next*8);\r\n        usersCollection.aggregate(Arrays.asList(filter, skip, limit)).forEach(convertInUser);\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param username\r\n     * @param password\r\n     * @return\r\n     */\r\n    public User login (String username, String password) {\r\n        Document result = (Document) usersCollection.find(Filters.and(eq(\"username\", username),\r\n                                                                eq(\"password\", password))).\r\n                                                                first();\r\n\r\n        Gson gson = new Gson();\r\n        return gson.fromJson(gson.toJson(result), User.class);\r\n    }\r\n\r\n    /**\r\n     * Add a new User to MongoDB\r\n     * @param u The object User which contains all the necessary information\r\n     * @return true if operation is successfully executed, false otherwise\r\n     */\r\n    public boolean addUser (User u) {\r\n        try {\r\n            Document doc = new Document(\"username\", u.getUsername())\r\n                                .append(\"email\", u.getEmail())\r\n                                .append(\"password\", u.getPassword());\r\n\r\n            if (u.getFirstName() != null)\r\n                doc.append(\"firstName\", u.getFirstName());\r\n            if (u.getLastName() != null)\r\n                doc.append(\"lastName\", u.getLastName());\r\n            if (u.getPicture() != null)\r\n                doc.append(\"picture\", u.getPicture());\r\n            if (u.getAge() != -1)\r\n                doc.append(\"age\", u.getAge());\r\n\r\n            doc.append(\"readingLists\", u.getReadingLists());\r\n\r\n            usersCollection.insertOne(doc);\r\n            return true;\r\n\r\n        } catch (Exception e) {\r\n            System.out.println(\"Error in adding a new user\");\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function that deletes the user from the database\r\n     * @param u user to delete\r\n     * @return true if operation is successfully executed, false otherwise\r\n     */\r\n    public boolean deleteUser(User u) {\r\n        try {\r\n            usersCollection.deleteOne(eq(\"username\", u.getUsername()));\r\n            return true;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            System.err.println(\"Error in delete user\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit an already present user\r\n     * @param u the new user information to replace the old one\r\n     * @return  true if operation is successfully executed, false otherwise\r\n     */\r\n    public boolean updateUser (User u){\r\n        try {\r\n            Document doc = new Document().append(\"username\", u.getUsername());\r\n            if (!u.getPassword().isEmpty())\r\n                doc.append(\"password\", u.getPassword());\r\n            if (!u.getFirstName().isEmpty())\r\n                doc.append(\"firstName\", u.getFirstName());\r\n            if (!u.getLastName().isEmpty())\r\n                doc.append(\"lastName\", u.getLastName());\r\n            if (!u.getPicture().isEmpty())\r\n                doc.append(\"picture\", u.getPicture());\r\n            if (u.getAge() != -1)\r\n                doc.append(\"age\", u.getAge());\r\n\r\n            Bson updateOperation = new Document(\"$set\", doc);\r\n            usersCollection.updateOne(new Document(\"username\", u.getUsername()), updateOperation);\r\n            return true;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            ex.printStackTrace();\r\n            System.err.println(\"Error in updating user on MongoDB\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Search a user by his username\r\n     * @param username username of the user\r\n     * @return User\r\n     */\r\n    public User getUserByUsername (String username) {\r\n        Document result = (Document) usersCollection.find((eq(\"username\", username))).first();\r\n        if (result == null) {\r\n            System.out.println(\"User \" + username + \" do not found.\");\r\n            return null;\r\n        }\r\n\r\n        Gson gson = new Gson();\r\n        return gson.fromJson(gson.toJson(result), User.class);\r\n    }\r\n\r\n    /**\r\n     * Add a new paper in MongoDB\r\n     * @param p The object Paper which contains all the necessary information about it\r\n     * @return  true if operation is successfully executed, false otherwise\r\n     */\r\n    public boolean addPaper (Paper p) {\r\n        try {\r\n            Document doc = new Document();\r\n            //Data conversion to string\r\n            SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");\r\n            String format = formatter.format(p.getPublished());\r\n\r\n            //Check paper source\r\n            if(!p.getArxivId().isEmpty())\r\n                doc.append(\"arxiv_id\", p.getArxivId()).append(\"vixra_id\", Float.NaN);\r\n            else\r\n                doc.append(\"arxiv_id\", Float.NaN).append(\"vixra_id\", p.getVixraId());\r\n\r\n            doc.append(\"_title\", p.getTitle())\r\n                    .append(\"_abstract\", p.getAbstract())\r\n                    .append(\"category\", p.getCategory())\r\n                    .append(\"authors\", p.getAuthors())\r\n                    .append(\"published\", format)\r\n                    //No comment on insert\r\n                    .append(\"comments\", null);\r\n\r\n            papersCollection.insertOne(doc);\r\n            return true;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            System.err.println(\"Error in adding a new paper\");\r\n            ex.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new comment\r\n     * @param id Id of the paper\r\n     * @param text text of the comment\r\n     * @return  true if operation is successfully executed, false otherwise\r\n     */\r\n    public boolean addComment (String id, String text, String user) {\r\n        try {\r\n            SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n            Document comment = new Document(\"username\", user)\r\n                    .append(\"text\",text)\r\n                    .append(\"timestamp\",dateFormat.format(new Date()));\r\n\r\n            Bson find = or(eq(\"arxiv_id\", id), eq(\"vixra_id\", id));\r\n            Bson update = Updates.addToSet(\"comments\", comment);\r\n            papersCollection.updateOne(find, update);\r\n            return true;\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            System.out.println(\"Error in adding a commnet to a Paper\");\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Update the list of comments of a paper\r\n     * @param p\r\n     * @param comments\r\n     * @return  true if operation is successfully executed, false otherwise\r\n     */\r\n    public boolean updateComments(Paper p, List<Comment> comments){\r\n        try{\r\n            Bson update = new Document(\"comments\", comments);\r\n            Bson updateOperation = new Document(\"$set\", update);\r\n            if(!p.getArxivId().isEmpty())\r\n                papersCollection.updateOne(new Document(\"arxiv_id\", p.getArxivId()), updateOperation);\r\n            else\r\n                papersCollection.updateOne(new Document(\"vixra_id\", p.getVixraId()), updateOperation);\r\n            return true;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            ex.printStackTrace();\r\n            System.err.println(\"Error in updating user on MongoDB\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update an existing comment\r\n     * @param paper\r\n     * @param comment\r\n     */\r\n    public void updateComment(Paper paper, Comment comment){\r\n        List<Comment> comments = paper.getComments();\r\n        int i=0;\r\n        for (Comment c: comments\r\n        ) {\r\n            if(c.getUsername().equals(comment.getUsername()) && c.getTimestamp().equals(\r\n                    comment.getTimestamp())){\r\n                comments.set(i, comment);\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        updateComments(paper, comments);\r\n    }\r\n\r\n    /**\r\n     * Add a new comment\r\n     * @param paper\r\n     * @param comment\r\n     */\r\n    public void deleteComment (Paper paper, Comment comment) {\r\n        List<Comment> comments = paper.getComments();\r\n        int n = 0;\r\n        int d = 0;\r\n        for (Comment c : comments){\r\n            if (c.getTimestamp().equals(comment.getTimestamp()) && c.getUsername().equals(comment.getUsername())) {\r\n                d = n;\r\n                break;\r\n            }\r\n        n++;\r\n        }\r\n        comments.remove(d);\r\n        updateComments(paper, comments);\r\n    }\r\n    /**\r\n     * Function that deletes the paper from the database\r\n     * @param p Paper to delete\r\n     * @return true if operation is successfully executed, false otherwise\r\n     */\r\n    public boolean deletePaper (Paper p) {\r\n        try {\r\n            if(!p.getArxivId().isEmpty())\r\n                papersCollection.deleteOne(eq(\"arxiv_id\", p.getArxivId()));\r\n            else\r\n                papersCollection.deleteOne(eq(\"vixra_id\", p.getVixraId()));\r\n\r\n            return true;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            System.err.println(\"Error in delete paper\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function that return the paper that matches the id\r\n     * @param id of the paper to retrieve\r\n     * @return the paper object\r\n     */\r\n    public Paper getPaperById (String id) {\r\n        try {\r\n            Paper p = null;\r\n            Gson gson = new GsonBuilder().setDateFormat(\"yyyy-MM-dd hh:mm:ss\").create();\r\n\r\n            Document myDoc = (Document) papersCollection.find(\r\n                    or(eq(\"arxiv_id\", id), eq(\"vixra_id\", id))).first();\r\n            p = gson.fromJson(gson.toJson(myDoc), Paper.class);\r\n            return p;\r\n        }\r\n        catch (JsonSyntaxException e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param title\r\n     * @param author\r\n     * @param start_date\r\n     * @param end_date\r\n     * @param category\r\n     * @return\r\n     */\r\n    public List<Paper> searchPapersByParameters (String title, String author, String start_date,\r\n                                                 String end_date, String category, int skip, int limit) {\r\n        List<Paper> papers = new ArrayList<>();\r\n        Gson gson = new GsonBuilder().setDateFormat(\"yyyy-MM-dd hh:mm:ss\").create();\r\n\r\n        List<Bson> pipeline = new ArrayList<>();\r\n\r\n        if (!title.isEmpty()) {\r\n            Pattern pattern1 = Pattern.compile(\"^.*\" + title + \".*$\", Pattern.CASE_INSENSITIVE);\r\n            pipeline.add(Aggregates.match(Filters.regex(\"title\", pattern1)));\r\n        }\r\n\r\n        if (!author.isEmpty()) {\r\n            Pattern pattern2 = Pattern.compile(\"^.*\" + author + \".*$\", Pattern.CASE_INSENSITIVE);\r\n            pipeline.add(Aggregates.match(Filters.regex(\"authors\", pattern2)));\r\n        }\r\n\r\n        if (!start_date.isEmpty()) {\r\n            pipeline.add(Aggregates.match(and(Filters.gte(\"published\", start_date))));\r\n        }\r\n\r\n        if(!end_date.isEmpty()) {\r\n            pipeline.add(Aggregates.match(and(Filters.lte(\"published\", end_date))));\r\n        }\r\n\r\n        if (!category.isEmpty()) {\r\n            pipeline.add(Aggregates.match(Filters.eq(\"category\", category)));\r\n        }\r\n\r\n        pipeline.add(sort(descending(\"published\")));\r\n        pipeline.add(skip(skip * limit));\r\n        pipeline.add(limit(limit));\r\n\r\n        List<Document> results = (List<Document>) papersCollection.aggregate(pipeline)\r\n                .into(new ArrayList<>());\r\n        Type papersListType = new TypeToken<ArrayList<Paper>>(){}.getType();\r\n        papers = gson.fromJson(gson.toJson(results), papersListType);\r\n        return papers;\r\n    }\r\n\r\n    /**\r\n     * Function that return the list of papers that partially match a title\r\n     * @param title title of the papers\r\n     * @return The list of papers\r\n     */\r\n    public List<Paper> searchPapersByTitle(String title) {\r\n        List<Paper> papers = new ArrayList<>();\r\n        Gson gson = new GsonBuilder().setDateFormat(\"yyyy-MM-dd hh:mm:ss\").create();\r\n        Pattern pattern = Pattern.compile(\"^.*\" + title + \".*$\", Pattern.CASE_INSENSITIVE);\r\n        Bson match = Aggregates.match(Filters.regex(\"title\", pattern));\r\n        Bson sort = sort(descending(\"published\"));\r\n\r\n        /*\r\n        Bson limit = limit(10);\r\n        Bson skip = skip();\r\n         */\r\n\r\n        List<Document> results = (List<Document>) papersCollection.aggregate(Arrays.asList(match, sort))\r\n                .into(new ArrayList<>());\r\n        Type papersListType = new TypeToken<ArrayList<Paper>>(){}.getType();\r\n        papers = gson.fromJson(gson.toJson(results), papersListType);\r\n        return papers;\r\n    }\r\n\r\n    /**\r\n     * Function that retrieves all the papers published by an author\r\n     * @param author name of the author\r\n     * @return list of Papers\r\n     */\r\n    public List<Paper> searchPaperByAuthor(String author) {\r\n        Gson gson = new GsonBuilder().setDateFormat(\"yyyy-MM-dd\").serializeSpecialFloatingPointValues().create();\r\n        List<Paper> results = new ArrayList<>();\r\n        Consumer<Document> transformDocument = doc -> {\r\n            Paper paper = gson.fromJson(gson.toJson(doc), Paper.class);\r\n            results.add(paper);\r\n        };\r\n        papersCollection.find(eq(\"authors\", author)).forEach(transformDocument);\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Return all the papers between a given time interval\r\n     * @param start_date start date\r\n     * @param end_date end date\r\n     * @return the list of Papers\r\n     */\r\n    public List<Paper> searchPapersByPublicationDate (String start_date, String end_date) {\r\n        List<Paper> papers = new ArrayList<>();\r\n        Gson gson = new GsonBuilder().setDateFormat(\"yyyy-MM-dd hh:mm:ss\").create();\r\n\r\n        Bson match = match(and(\r\n                Filters.gte(\"published\", start_date),\r\n                Filters.lte(\"published\", end_date)));\r\n        Bson sort = sort(descending(\"published\"));\r\n\r\n        /*\r\n        Bson limit = limit(10);\r\n        Bson skip = skip();\r\n         */\r\n\r\n        List<Document> results = (List<Document>) papersCollection.aggregate(Arrays.asList(match, sort))\r\n                .into(new ArrayList<>());\r\n        Type papersListType = new TypeToken<ArrayList<Paper>>(){}.getType();\r\n        papers = gson.fromJson(gson.toJson(results), papersListType);\r\n        return papers;\r\n    }\r\n\r\n    /**\r\n     * Function that return the list of papers related to a category\r\n     * @param category Category of the papers\r\n     * @return The list of papers\r\n     */\r\n    public List<Paper> searchPapersByCategory(String category){\r\n\r\n        List<Paper> papers = new ArrayList<>();\r\n        Gson gson = new GsonBuilder().setDateFormat(\"yyyy-MM-dd hh:mm:ss\").create();\r\n        List<Document> results = (List<Document>) papersCollection.find(eq(\"category\", category))\r\n                .into(new ArrayList<>());\r\n        Type paperListType = new TypeToken<ArrayList<Paper>>(){}.getType();\r\n        papers = gson.fromJson(gson.toJson(results), paperListType);\r\n        return papers;\r\n    }\r\n\r\n    /**\r\n     * Add a new empty reading list called \"title\" list at the user identify by username\r\n     * @param username username of the user\r\n     * @param title title of the new reading list\r\n     * @return true if it adds the reading list, otherwise it returns false\r\n     */\r\n    public boolean createReadingList(String username, String title) {\r\n        // check if there are other list with the same name\r\n        Document document = (Document) usersCollection.find(and(eq(\"username\", username),\r\n                eq(\"readingLists.title\", title))).first();\r\n        if (document != null) {\r\n            System.err.println(\"ERROR: name already in use.\");\r\n            return false;\r\n        }\r\n        // create the new reading_list\r\n        Document readingList = new Document(\"title\", title)\r\n                .append(\"papers\", Arrays.asList());\r\n        // insert the new reading_list\r\n        usersCollection.updateOne(\r\n                eq(\"username\", username),\r\n                new Document().append(\r\n                        \"$push\",\r\n                        new Document(\"readingLists\", readingList)\r\n                )\r\n        );\r\n        System.out.println(\"Reading list \" + title + \" has been added\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Delete the reading list of user by specifying the title\r\n     * @param username username of the user\r\n     * @param title title of the reading list which i want remove\r\n     * @return true if it removes the reading list, otherwise it returns false\r\n     */\r\n    public boolean deleteReadingList(String username, String title){\r\n        Bson filter = new Document().append(\"username\", username);\r\n        Bson fields = new Document().append(\"readingLists\", new Document(\"title\", title));\r\n        Bson update = new Document(\"$pull\", fields);\r\n        UpdateResult updateResult = usersCollection.updateOne(filter, update);\r\n        if (updateResult.getModifiedCount() == 0){\r\n            System.err.println(\"ERROR: can not delete the reading list \" + title);\r\n            return false;\r\n        } else {\r\n            System.out.println(\"Reading list \" + title + \" has been deleted\");\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method that adds a Paper to a ReadingList\r\n     * @param user owner of the ReadingList\r\n     * @param p Paper\r\n     * @return true if the operation is successfully executed, false otherwise\r\n     */\r\n    public UpdateResult addPaperToReadingList(String user, String title, Paper p) {\r\n        Document paperReduced = new Document(\"arxiv_id\", p.getArxivId())\r\n                .append(\"vixra_id\", p.getVixraId())\r\n                .append(\"title\", p.getTitle())\r\n                .append(\"auhtors\", p.getAuthors())\r\n                .append(\"category\", p.getCategory());\r\n        Bson find = and(eq(\"username\", user),\r\n                eq(\"readingLists.title\", title));\r\n        Bson update = Updates.addToSet(\"readingLists.$.papers\", paperReduced);\r\n        UpdateResult result = usersCollection.updateOne(find, update);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Method that remove a Paper from a ReadingList\r\n     * @param user ReadingList\r\n     * @param p Paper\r\n     * @return true if the operation is successfully executed, false otherwise\r\n     */\r\n    public boolean removePaperFromReadingList(String user, String title, Paper p) {\r\n        try {\r\n            Document paperReduced = new Document(\"arxiv_id\", p.getArxivId())\r\n                    .append(\"vixra_id\", p.getVixraId())\r\n                    .append(\"title\", p.getTitle())\r\n                    .append(\"auhtors\", p.getAuthors());\r\n\r\n            Bson find = and(eq(\"username\", user),\r\n                    eq(\"reading_lists.title\", title));\r\n            Bson delete = Updates.pull(\"reading_lists.$.papers\", paperReduced);\r\n            usersCollection.updateOne(find, delete);\r\n            return true;\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            System.out.println(\"Error in removing a paper from a Reading List\");\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns all the Reading Lists in the database MongoDB\r\n     * @return The list of the Reading List\r\n     */\r\n    public List<ReadingList> showReadingList() {\r\n        List<ReadingList> readingLists = new ArrayList<>();\r\n        Gson gson = new GsonBuilder().serializeNulls().create();\r\n        Bson unwind = unwind(\"$reading_lists\");\r\n        Bson project = project(fields(excludeId(), computed(\"ReadingList\", \"$reading_lists\")));\r\n\r\n        MongoCursor<Document> iterator = (MongoCursor<Document>)\r\n                usersCollection.aggregate(Arrays.asList(unwind, project)).iterator();\r\n\r\n        Type readingListType = new TypeToken<ArrayList<ReadingList>>(){}.getType();\r\n        while (iterator.hasNext())\r\n        {\r\n            Document document = iterator.next();\r\n            System.out.println(document);\r\n            Document ReadingListDocument = (Document) document.get(\"ReadingList\");\r\n            ReadingList readingList = gson.fromJson(gson.toJson(ReadingListDocument), ReadingList.class);\r\n            readingLists.add(readingList);\r\n        }\r\n\r\n        return readingLists;\r\n    }\r\n\r\n    /**\r\n     * Function that return the ReadingLists given the user\r\n     * @param username Username of the user\r\n     * @return  The list of reading lists\r\n     */\r\n    public List<ReadingList> getReadingListByUser (String username){\r\n        List<ReadingList> readingLists = new ArrayList<>();\r\n        Gson gson = new GsonBuilder().serializeNulls().create();\r\n\r\n        Bson match = match(eq(\"username\", username));\r\n        Bson unwind = unwind(\"$reading_lists\");\r\n        Bson project = project(fields(excludeId() ,computed(\"ReadingList\", \"$reading_lists\")));\r\n        MongoCursor<Document> iterator = (MongoCursor<Document>) usersCollection.aggregate(Arrays.asList(match, unwind, project)).iterator();\r\n        while (iterator.hasNext())\r\n        {\r\n            Document document = iterator.next();\r\n            Document ReadingListDocument = (Document) document.get(\"ReadingList\");\r\n            ReadingList readingList = gson.fromJson(gson.toJson(ReadingListDocument), ReadingList.class);\r\n            readingLists.add(readingList);\r\n        }\r\n\r\n        return readingLists;\r\n    }\r\n\r\n    /**\r\n     * Function that return the ReadingLists given the user and the name\r\n     * @param username Username of the user\r\n     * @param title Name of the reading list\r\n     * @return  The list of reading lists\r\n     */\r\n    public ReadingList getReadingList (String username, String title) {\r\n        ReadingList readingList = null;\r\n        Gson gson = new GsonBuilder().serializeNulls().create();\r\n\r\n        Bson match = match(eq(\"username\", username));\r\n        Bson unwind = unwind(\"$readingLists\");\r\n        Bson match2 = match(eq(\"readingLists.title\", title));\r\n        Bson project = project(fields(excludeId(), computed(\"ReadingList\", \"$readingLists\")));\r\n        MongoCursor<Document> iterator = (MongoCursor<Document>) usersCollection.aggregate(Arrays.asList(match, unwind, match2, project)).iterator();\r\n        if(iterator.hasNext()){\r\n            Document document = iterator.next();\r\n            Document ReadingListDocument = (Document) document.get(\"ReadingList\");\r\n            readingList = gson.fromJson(gson.toJson(ReadingListDocument), ReadingList.class);\r\n        }\r\n        return readingList;\r\n    }\r\n\r\n    /**\r\n     * Function that return the ReadingLists given the name\r\n     * @param keyword part of the title\r\n     * @return  The list of reading lists and its owner\r\n     */\r\n    public List<Pair<String, ReadingList>> getReadingListByKeywords (String keyword) {\r\n        List<Pair<String, ReadingList>> readingLists = new ArrayList<>();\r\n        Gson gson = new GsonBuilder().serializeNulls().create();\r\n\r\n        Bson unwind = unwind(\"$readingLists\");\r\n        Pattern pattern= Pattern.compile(\"^.*\" + keyword + \".*$\", Pattern.CASE_INSENSITIVE);\r\n        Bson filter = Aggregates.match(Filters.regex(\"readingLists.title\", pattern));\r\n        MongoCursor<Document> iterator = (MongoCursor<Document>) usersCollection.aggregate(Arrays.asList(unwind, filter)).iterator();\r\n        while(iterator.hasNext()){\r\n            Document document = iterator.next();\r\n            String username = document.getString(\"username\");\r\n            Document ReadingListDocument = (Document) document.get(\"readingLists\");\r\n            ReadingList readingList = gson.fromJson(gson.toJson(ReadingListDocument), ReadingList.class);\r\n            readingLists.add(new Pair<>(username, readingList));\r\n        }\r\n        return readingLists;\r\n    }\r\n\r\n    /**\r\n     * Function that returns the most common category in a Reading List\r\n     * @param user Reading List to process\r\n     * @return the name of the category\r\n     */\r\n    public String getMostCommonCategoryInReadingList(String user, String title) {\r\n\r\n        Bson match1 = match(Filters.eq(\"username\", user));\r\n        Bson unwind1 = unwind(\"$reading_lists\");\r\n        Bson match2 = match(Filters.eq(\"reading_lists.title\", title));\r\n        Bson unwind2 = unwind(\"$reading_lists.papers\");\r\n        Bson group = group(\"$reading_lists.papers.category\",\r\n                sum(\"nPapers\", 1));\r\n        Bson sort = sort(descending(\"nPapers\"));\r\n        Bson project = project(fields(computed(\"category\", \"$_id\"),\r\n                excludeId(), include(\"nPapers\")));\r\n\r\n        Document doc = (Document) usersCollection.aggregate(\r\n                Arrays.asList(match1, unwind1, match2, unwind2, group, sort, project)).first();\r\n\r\n        String mostCommonCategory = doc.getString(\"category\");\r\n\r\n        return mostCommonCategory;\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     * @return\r\n     */\r\n    public List<Pair<String, Integer>> getCategoriesSummaryByLikes(/*String option*/) {\r\n\r\n        List<Pair<String, Integer>> topCategories = new ArrayList<>();\r\n\r\n        Bson group = group(\"$category\", sum(\"nPapers\", 1));\r\n        Bson sort = sort(descending(\"nPapers\"));\r\n        Bson project = project(fields(computed(\"category\", \"$_id\"),\r\n                excludeId(), include(\"nPapers\")));\r\n\r\n        try(MongoCursor<Document> cursor = papersCollection.aggregate(Arrays.asList(group, sort, project))\r\n                                    .iterator()) {\r\n            while(cursor.hasNext()) {\r\n                Document doc = cursor.next();\r\n                String category = doc.getString(\"category\");\r\n                int nPapers = doc.getInteger(\"nPapers\");\r\n                topCategories.add(new Pair<>(category, nPapers));\r\n            }\r\n        }\r\n        catch (Exception e) {\r\n            System.out.println(\"Error in getting number of papers by category\");\r\n            e.printStackTrace();\r\n        }\r\n\r\n        return topCategories;\r\n    }\r\n\r\n    /*Weekly/Monthly/All time summary of the categories by number of papers Published */\r\n    /**\r\n     * Function that return the top categories by the number of papaer published\r\n     * @param start initial date\r\n     * @param finish final date\r\n     * @param number number of results to show\r\n     * @return The list of the most common categories\r\n     */\r\n    public List<String> summaryOfCategory (String start, String finish, int number){\r\n        List<String> mostCommonCategories = new ArrayList<>();\r\n\r\n        Bson match = match(and(gte(\"published\", start), lte(\"published\", finish)));\r\n        Bson group = group(\"$category\", sum(\"totalPaper\", 1));\r\n        Bson project = project(fields(excludeId(), computed(\"category\", \"$_id\"), include(\"totalPaper\")));\r\n        Bson sort = sort(descending(\"totalPaper\"));\r\n        Bson limit = limit(number);\r\n\r\n        List<Document> results = (List<Document>) papersCollection.aggregate(Arrays.asList(match, group, project, sort, limit)).into(new ArrayList<>());\r\n\r\n        for (Document document: results)\r\n        {\r\n            mostCommonCategories.add(document.getString(\"category\"));\r\n        }\r\n        return mostCommonCategories;\r\n    }\r\n\r\n    /*Users with the highest number of categories in their reading lists  */\r\n    /**\r\n     * Function that return a list of User with the highest number of reading lists\r\n     * @param number First \"number\" users\r\n     * @return  The list of users\r\n     */\r\n    public List<String> searchUsersWithHighestNumberOfCategories (int number)\r\n    {\r\n        List<String> mostCommonCategories = new ArrayList<>();\r\n\r\n        Bson unwind1 = unwind(\"$reading_lists\");\r\n        Bson unwind2 = unwind(\"$reading_lists.papers\");\r\n        Bson groupMultiple = new Document(\"$group\",\r\n                new Document(\"_id\", new Document(\"username\", \"$username\").append(\"category\", \"$reading_lists.papers.category\")));\r\n        Bson group = group(\"$_id.username\", sum(\"totalCategory\", 1));\r\n        Bson project = project(fields(excludeId(), computed(\"username\", \"$_id\"), include(\"totalCategory\")));\r\n        Bson sort = sort(descending(\"totalCategory\"));\r\n        Bson limit = limit(number);\r\n\r\n        List<Document> results = (List<Document>) usersCollection.aggregate(Arrays.asList(unwind1, unwind2, groupMultiple, group, project, sort, limit)).into(new ArrayList<>());\r\n        for (Document document: results)\r\n        {\r\n            mostCommonCategories.add(document.getString(\"username\"));\r\n        }\r\n        return mostCommonCategories;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Braws all comments that has been written \"numDays\" ago\r\n     * @param numDays how may day i want to scan\r\n     * @return list of comments\r\n     */\r\n    public List<Comment> searchLastComments(int numDays) {\r\n        // create the date\r\n        LocalDateTime localDateTime = LocalDateTime.now().minusDays(numDays);\r\n        LocalDateTime startOfDay = localDateTime.toLocalDate().atStartOfDay();\r\n        String filterDate = startOfDay.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"));\r\n\r\n        Gson gson = new GsonBuilder().setDateFormat(\"yyyy-MM-dd HH:mm:ss\").serializeSpecialFloatingPointValues().create();\r\n        List<Comment> results = new ArrayList<>();\r\n        Consumer<Document> takeComments = doc -> {\r\n            Document docComments = (Document) doc.get(\"comments\");\r\n            Comment comment = gson.fromJson(gson.toJson(docComments), Comment.class);\r\n            results.add(comment);\r\n        };\r\n\r\n        Bson unwind = unwind(\"$comments\");\r\n        Bson filter = match(gte(\"comments.timestamp\", filterDate));\r\n        Bson sort = sort(ascending(\"comments.timestamp\"));\r\n        papersCollection.aggregate(Arrays.asList(unwind, filter, sort)).forEach(takeComments);\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Browse the top categories with more comments\r\n     * @param period (all, month, week)\r\n     * @param top (positive integer)\r\n     * @return HashMap with the category and the number of comments\r\n     */\r\n    public List<Pair<String, Integer>> summaryCategoriesByComments(String period, int top) {\r\n        LocalDateTime localDateTime = LocalDateTime.now();\r\n        LocalDateTime startOfDay;\r\n        switch (period) {\r\n            case \"all\" -> startOfDay = LocalDateTime.MIN;\r\n            case \"month\" -> startOfDay = localDateTime.toLocalDate().atStartOfDay().minusMonths(1);\r\n            case \"week\" -> startOfDay = localDateTime.toLocalDate().atStartOfDay().minusWeeks(1);\r\n            default -> {\r\n                System.err.println(\"ERROR: Wrong period.\");\r\n                return null;\r\n            }\r\n        }\r\n        String filterDate = startOfDay.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"));\r\n\r\n        List<Pair<String, Integer>> results = new ArrayList<>();\r\n        Consumer<Document> rankCategories = doc ->\r\n                results.add(new Pair<>((String) doc.get(\"_id\"), (Integer) doc.get(\"tots\")));\r\n\r\n        Bson unwind = unwind(\"$comments\");\r\n        Bson filter = match(gte(\"comments.timestamp\", filterDate));\r\n        Bson group = group(\"$category\", sum(\"tots\", 1));\r\n        Bson sort = sort(Indexes.descending(\"tots\"));\r\n        Bson limit = limit(top);\r\n        papersCollection.aggregate(Arrays.asList(unwind, filter, group, sort, limit)).forEach(rankCategories);\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Browse the top papers with more comments\r\n     * @param period (all, month, week)\r\n     * @param top (positive integer)\r\n     * @return HashMap with the title and the number of comments\r\n     */\r\n    public List<Pair<String, Integer>> summaryPapersByComments(String period, int top) {\r\n        LocalDateTime localDateTime = LocalDateTime.now();\r\n        LocalDateTime startOfDay;\r\n        switch (period) {\r\n            case \"all\" -> startOfDay = LocalDateTime.MIN;\r\n            case \"month\" -> startOfDay = localDateTime.toLocalDate().atStartOfDay().minusMonths(1);\r\n            case \"week\" -> startOfDay = localDateTime.toLocalDate().atStartOfDay().minusWeeks(1);\r\n            default -> {\r\n                System.err.println(\"ERROR: Wrong period.\");\r\n                return null;\r\n            }\r\n        }\r\n        String filterDate = startOfDay.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"));\r\n\r\n        List<Pair<String, Integer>> results = new ArrayList<>();\r\n        Consumer<Document> rankPapers = doc ->\r\n                results.add(new Pair<>((String) doc.get(\"_id\"), (Integer) doc.get(\"tots\")));\r\n\r\n        Bson unwind = unwind(\"$comments\");\r\n        Bson filter = match(gte(\"comments.timestamp\", filterDate));\r\n        Bson group = group(\"$title\", sum(\"tots\", 1));\r\n        Bson sort = sort(Indexes.descending(\"tots\"));\r\n        Bson limit = limit(top);\r\n        papersCollection.aggregate(Arrays.asList(unwind, filter, group, sort, limit)).forEach(rankPapers);\r\n\r\n        return results;\r\n    }\r\n\r\n    public List<String> getCategories() {\r\n        List<String> categoriesList = new ArrayList<>();\r\n        papersCollection.distinct(\"category\", String.class).into(categoriesList);\r\n        return categoriesList;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/PaperRaterApp/src/main/java/it/unipi/dii/lsmd/paperraterapp/persistence/MongoDBManager.java b/PaperRaterApp/src/main/java/it/unipi/dii/lsmd/paperraterapp/persistence/MongoDBManager.java
--- a/PaperRaterApp/src/main/java/it/unipi/dii/lsmd/paperraterapp/persistence/MongoDBManager.java	(revision 7a9f9417084cd57d34a26ea6942ee6d3c4569db0)
+++ b/PaperRaterApp/src/main/java/it/unipi/dii/lsmd/paperraterapp/persistence/MongoDBManager.java	(date 1640627086730)
@@ -670,14 +670,16 @@
      * @param keyword part of the title
      * @return  The list of reading lists and its owner
      */
-    public List<Pair<String, ReadingList>> getReadingListByKeywords (String keyword) {
+    public List<Pair<String, ReadingList>> getReadingListByKeywords (String keyword, int limitDoc, int skipDoc) {
         List<Pair<String, ReadingList>> readingLists = new ArrayList<>();
         Gson gson = new GsonBuilder().serializeNulls().create();
 
         Bson unwind = unwind("$readingLists");
         Pattern pattern= Pattern.compile("^.*" + keyword + ".*$", Pattern.CASE_INSENSITIVE);
         Bson filter = Aggregates.match(Filters.regex("readingLists.title", pattern));
-        MongoCursor<Document> iterator = (MongoCursor<Document>) usersCollection.aggregate(Arrays.asList(unwind, filter)).iterator();
+        Bson skip = skip(skipDoc);
+        Bson limit = limit(limitDoc);
+        MongoCursor<Document> iterator = (MongoCursor<Document>) usersCollection.aggregate(Arrays.asList(unwind, filter, skip, limit)).iterator();
         while(iterator.hasNext()){
             Document document = iterator.next();
             String username = document.getString("username");
